#!/bin/bash
#/ groundskeeper, Version 0.0.2
#/ Copyright 2019, Graham Weldon <graham@grahamweldon.com>
#/

CLONE_DEPTH=1
CORE_PLANS_GIT_URI="git@github.com:habitat-sh/core-plans.git"
CLONE_DIR="core-plans"
STUDIO_TYPE="groundskeeper"
DEBUG=${DEBUG:-0}
ALL_PLANS=()

debug_echo() {
  if [ ${DEBUG} -eq 0 ]; then
    return 0
  fi

  echo "${@}" >&2
}

# Prepare dependencies for this script
# - Habitat repo (contains REPL attach command)
prepare_dependencies() {
  echo "[ Habitat ] ------------------------------------------"
  if [ ! -d habitat ]; then
    git clone --depth "${CLONE_DEPTH}" git@github.com:habitat-sh/habitat.git habitat
    return $?
  fi
  update_repository habitat
  return $?
}

# Clone the core-plans repository
clone_repository() {
  echo "[ Core Plans ] ------------------------------------------"
  if [ ! -d "${CLONE_DIR}" ]; then
    git clone --depth "${CLONE_DEPTH}" "${CORE_PLANS_GIT_URI}" "${CLONE_DIR}"
    return $?
  fi
  update_repository "${CLONE_DIR}"
  return $?
}

# Update the repository in the specified directory (must already exist)
# ```
# update_repository habitat
# ```
update_repository() {
  pushd "${1}" > /dev/null
    git remote update && \
    git reset --hard origin/master
    status=$?
  popd > /dev/null
  return ${status}
}

# Get an array of all plans
get_all_plans() {
  ALL_PLANS=($(find "${CLONE_DIR}" -name plan.sh -d 2 | sort | awk -F'/' '{print $2}'))
}

debug_plans() {
  for plan in "${ALL_PLANS[@]}"; do
    echo " - ${plan}"
  done
}

do_latest_version() {
  do_default_latest_version "${1}"
}

# Meta function, to find latest release from any plan.
# The hard work is done in other functions, this ties them together.
do_default_latest_version() {
  local plan="${1}"
  local is_github=0
  local pkg_source_line=""

  pushd "${CLONE_DIR}/${plan}" > /dev/null
    pkg_source_line=$(cat plan.sh | grep "^pkg_source=")
  popd > /dev/null

  case "${plan}" in
    R)
      do_r_latest_version
      return $?
      ;;
    ansible)
      do_ansible_latest_version
      return $?
      ;;
    acl)
      do_acl_latest_version
      return $?
      ;;
    alex)
      do_alex_latest_version
      return $?
      ;;
    alsa-lib)
      do_alsa_lib_latest_version
      return $?
      ;;
    ant)
      # ant currently references github - Maybe that should change in its plan.sh
      apache_latest_version apache-ant ant/source
      return $?
      ;;
    artifactory|artifactory-pro)
      do_artifactory_latest_version
      return $?
      ;;
    bash-static)
      # bash-static sources bash
      do_default_latest_version "bash"
      return $?
      ;;
    lsof)
      do_lsof_latest_version
      return $?
      ;;
    *)
      if [[ "${plan}" =~ ^postgresql ]]; then
        postgresql_code="$(echo "${plan}" | sed 's/postgresql//')"
        do_postgresql_latest_version "${postgresql_code}"
        return $?
      fi

      if [[ "${pkg_source_line}" =~ github\.com\/.*\/archive\/ ]]; then
        is_github=1
        repo_ident=$(github_repo_ident "${plan}")
        github_latest_version "${repo_ident}"
        return $?
      fi

      if [[ "${pkg_source_line}" =~ downloads\.sourceforge\.net\/ ]]; then
        project_name="$(sourceforge_project_name "${plan}")"
        sourceforge_latest_version "${project_name}"
        return $?
      fi

      if [[ "${pkg_source_line}" =~ archive\.apache\.org ]]; then
        local apache_dir="${plan}"
        if [ "${plan}" = "apr-util" ]; then
          apache_dir="apr"
        fi
        apache_latest_version "${plan}" "${apache_dir}"
        return $?
      fi

      if [[ "${pkg_source_line}" =~ download\.gnome\.org ]]; then
        gnome_latest_version "${plan}"
        return $?
      fi

      if [[ "${pkg_source_line}" =~ download\.savannah\.gnu\.org ]]; then
        savannah_gnu_latest_version "${plan}"
        return $?
      fi

      if [[ "${pkg_source_line}" =~ ftp\.gnu\.org ]]; then
        ftp_gnu_latest_version "${plan}"
        return $?
      fi

      if [[ "${pkg_source_line}" =~ www\.x\.org ]]; then
        local xorg_type="lib"
        if [[ "${pkg_source_line}" =~ \/proto\/ ]]; then
          xorg_type="proto"
        fi
        if [[ "${pkg_source_line}" =~ \/app\/ ]]; then
          xorg_type="app"
        fi
        if [[ "${pkg_source_line}" =~ \/xcb\/ ]]; then
          xorg_type="xcb"
        fi
        xorg_latest_version "${plan}" "${xorg_type}"
        return $?
      fi
      ;;
  esac
}

# Check 'github releases' for the latest version of a repo
#
# 1. Get latest release from github
# 2. If (1) is a pre-release, try fetching the latest non-prerelease from all releases
# 3. If (1) is invalid/null, try fetching the latest non-prerelease from all releases
# 
# ```
# github_latest_release owner/repo-name
# ```
github_latest_version() {
  local ident="${1}"

  # Some repositories use Releases correctly. Those are by far the simplest cases.
  local latest_json=$(curl -u ${GITHUB_USERNAME}:${GITHUB_TOKEN} -s "https://api.github.com/repos/${ident}/releases/latest")
  local is_prerelease=$(echo "${latest_json}" | jq -r '.prerelease or .draft')
  if [ "${is_prerelease}" = "true" ]; then
    github_newest_release "${ident}"
    return $?
  fi

  local latest_version=$(echo "${latest_json}" | jq -r '.tag_name')

  # If the releases are empty, we can also check tags as an alternative
  if [ "${latest_version}" = "" -o "${latest_version}" = "null" ]; then
    # TODO: Search for latest tag?
    echo "unknown"
    return 1
  fi

  echo "${latest_version}"
  return 0
}

github_newest_release() {
  local latest_json=$(curl -u ${GITHUB_USERNAME}:${GITHUB_TOKEN} -s "https://api.github.com/repos/${ident}/releases")

  local is_prerelease=$(echo "${latest_json}" | jq -r '.prerelease or .draft')
}

# Get the github repo ident (owner/repo) from a pkg_source line
github_repo_ident() {
  local plan="${1}"
  local ident=""
  pushd "${CLONE_DIR}/${plan}" > /dev/null
    ident=$(cat plan.sh \
      | grep pkg_source \
      | grep "github\.com\/.*\/archive\/" \
      | sed -E 's/^.*github\.com\/([^\/]+)\/([^\/]+)\/.*/\1\/\2/')
  popd > /dev/null

  if [ "${ident}" = "" ]; then
    echo "Github: unknown/unknown"
    return 1
  fi

  echo "${ident}"
  return 0
}

sourceforge_latest_version() {
  local ident="${1}"
  latest_version=$(curl -s -I -L -D - "https://sourceforge.net/projects/${ident}/files/latest/download?source=files" -o /dev/null \
    | grep 'filename=' \
    | sed 's/^.*filename="\([^"]*\)".*/\1/' \
    | sed 's/\.tar\.bz2$//' \
    | sed 's/_src_all$//')
  status=$?

  if [ "${latest_version}" = "" ] && [ $status ]; then
    echo "unknown"
    return 1
  fi

  echo "${latest_version}"
  return 0
}

# Get the project name from a pkg_source line
sourceforge_project_name() {
  local plan="${1}"
  local ident=""
  pushd "${CLONE_DIR}/${plan}" > /dev/null
    ident=$(cat plan.sh \
      | grep pkg_source \
      | sed -E 's/^.*downloads.sourceforge\.net\/project\/([^\/]+)\/.*$/\1/')
  popd > /dev/null

  if [ "${ident}" = "" ]; then
    echo "Sourceforge: unknown"
    return 1
  fi

  echo "${ident}"
  return 0
}

# Get the latest version from the apache archive. Takes 2 arguments: Directory and PackageName
apache_latest_version() {
  local plan="${1}"
  local directory="${2:-1}"

  echo "$(curl -s "https://archive.apache.org/dist/${directory}/" \
    | grep "${plan}-[0-9]" \
    | grep -v -E "\.(asc|md5|sha)" \
    | sed -E 's/^.*(zip|bz2|gz|xz|Z|7z|lz)">([^<]*)<\/a>.*$/\2/' \
    | sed -E 's/^(.*)\.(tar\.(bz2|gz|xz|Z|lz)|zip|7z)/\1/' \
    | grep -v "RC" \
    | grep -v "win32" \
    | sed 's/-src$//' \
    | sort --version-sort \
    | uniq \
    | tail -1)"
  return 0
}

# Get the latest version from downloads.gnome.org. Takes plan as argument
gnome_latest_version() {
  local plan="${1}"
  echo "$(curl -s https://download.gnome.org/sources/${plan}/cache.json \
    | jq -r --arg PLAN_NAME "${plan}" '.[2][$PLAN_NAME] | .[]' \
    | sort --version-sort \
    | tail -1)"
  return 0
}

# Get the latest version from the GNU Savannah server. Takes plan as argument
savannah_gnu_latest_version() {
  local plan="${1}"
  echo "$(curl -s "https://download.savannah.gnu.org/releases/${plan}/" \
    | grep "${plan}-[0-9]" \
    | grep -v '\.sig">' \
    | sed -E 's/^.*(gz|bz2|xz|Z|lz)">([^<]*)\.tar\.(gz|bz2|xz|Z|lz)<\/a>.*/\2/' \
    | sed -E 's/\.(src\.)?tar\.gz//' \
    | egrep -v '(rc[0-9]+|pre)' \
    | egrep -v '\-w32\.zip' \
    | sort --version-sort \
    | tail -1)"
  return 0
}

# Get the latest version from the GNU FTP server. Takes plan as argument
ftp_gnu_latest_version() {
  local plan="${1}"
  echo "$(curl -s "https://ftp.gnu.org/gnu/${plan}/" \
    | grep "${plan}" \
    | egrep '\.tar\.(gz|bz2|xz|Z|lz)"' \
    | grep -v latest \
    | sed -E 's/^.*(gz|bz2|xz|Z|lz)">([^<]*)\.tar\.(gz|bz2|xz|Z|lz)<\/a>.*/\2/' \
    | sort --version-sort \
    | tail -1)"
  return 0
}

xorg_latest_version() {
  local plan="${1}"
  local xorg_type="${2:-lib}"

  local xorg_cache="${cache_xorg_lib}"
  case "${xorg_type}" in
    app)
      xorg_cache="${cache_xorg_app}"
      ;;
    proto)
      xorg_cache="${cache_xorg_proto}"
      ;;
    xcb)
      xorg_cache="${cache_xorg_xcb}"
      ;;
  esac

  echo "${xorg_cache}" \
    | grep -i "${plan}" \
    | grep -v '\.sig"' \
    | sed -E 's/^.*(gz|bz2|xz|Z)">([^<]*)\.tar\.(gz|bz2|xz|Z)<\/a>.*/\2/' \
    | sort --version-sort \
    | tail -1
  return 0
}

# Attempt to clean up a version string, takes the plan name as a parameter
# in case it has a special / weird ruleset.
# ```
# clean_version_string v0.4.0 acbuild
# clean_version_string v0.4.0
# ```
clean_version_string() {
  local version="${1}"
  local plan="${2:-}"
  local clean_version="${version}"
  debug_echo "Cleaning version: ${version} (${plan})"

  # lowercase the string - BSD sed doesn't do case insensitive matching.
  plan="$(echo "${plan}" | tr '[:upper:]' '[:lower:]')"
  clean_version="$(echo "${clean_version}" | tr '[:upper:]' '[:lower:]')"

  # TODO: Variable substitution used in the pkg_version (eg: bash)
  # if [[ "${version}" =~ "\${" ]]; then
  #   local variable = "$(echo "${version}" | sed -E 's/\${([^}]+)}/\1/')"
  #   debug_echo "Embedded variable ${variable}"
  # fi

  if [ "${plan}" = "7zip" ]; then
    plan="p7zip"
  fi

  # Remove preceding 'v'
  clean_version="$(echo "${clean_version}" | sed 's/^v//')"

  # Remove preceding plan name (eg: azure-cli, 7zip), and also
  # checking for apache- prefix
  clean_version="$(echo "${clean_version}" | sed -E "s/^(apache-)?${plan}[-_]//")"

  # Remove preceding plan name without hyphens (eg: c-ares)
  local no_hyphen_name="$(echo "${plan}" | sed 's/-//')"
  clean_version="$(echo "${clean_version}" | sed -E "s/^(apache-)?${no_hyphen_name}[-_]//")"

  debug_echo "Cleaned version: ${clean_version}"
  echo "${clean_version}"
  return 0
}

# Get the current version of a plan
# ```
# plan_version hugo
# ```
plan_version() {
  local version=""
  pushd "${CLONE_DIR}/${plan}" > /dev/null
    version=$(cat plan.sh | grep "^pkg_version=" | sed -E "s/pkg_version=[\"']?([^\"']+)[\"']?/\1/g")
  popd > /dev/null

  if [ "${version}" = "" ]; then
    return 1
  fi

  echo "${version}"
  return 0
}

# **Internal** Used to override the interactive shell/debugging session
# borrowed from hab-plan-build.
_attach_whereami() {
  echo
}

check_environment() {
  if [ -z "${GITHUB_TOKEN:-}" -o -z "${GITHUB_USERNAME}" ]; then
    echo "You must set your Github Username and Token:"
    echo "  export GITHUB_TOKEN=\"16469f23c164a8a92fd3c438e06a5ae2340d7f14\""
    echo "  export GITHUB_USERNAME=\"predominant\""
    echo
    echo "You can create a Github personal access token here:"
    echo "  https://github.com/settings/tokens/new"
    echo
    exit 1
  fi
}

check_environment
prepare_dependencies || exit 1
echo
clone_repository || exit 1
echo

source habitat/components/plan-build/bin/public.bash
source habitat/components/plan-build/bin/shared.bash

source "$(dirname ${0})/_plan_specific.bash"

# Cache the x.org lists, because they're all on the same page.
cache_xorg_lib="$(curl -s https://www.x.org/releases/individual/lib/)"
cache_xorg_app="$(curl -s https://www.x.org/releases/individual/app/)"
cache_xorg_proto="$(curl -s https://www.x.org/releases/individual/proto/)"
cache_xorg_xcb="$(curl -s https://www.x.org/releases/individual/xcb/)"

get_all_plans

plan_count_total=0
detected_version_total=0

for plan in "${ALL_PLANS[@]}"; do
  if [[ "${plan}" =~ ^scaffolding ]]; then
    # Skip scaffolding plans.
    continue
  fi

  plan_count_total=$((plan_count_total + 1))

  if [ ${DEBUG} -eq 1 ]; then
    echo
  fi

  # pv = Plan Version
  pv=$(plan_version "${plan}")
  pv_status=$?
  # lv = Latest Version
  lv=$(clean_version_string "$(do_latest_version "${plan}")" "${plan}")
  lv_status=$?

  update_status="| "
  if [ ${lv_status} -eq 0 ] && [ "${pv}" != "${lv}" ]; then
    update_status="> "
  fi
  if [ "${lv}" = "unknown" ] || [ "${lv}" = "" ] || [ -z "${lv}" ]; then
    update_status="- "
  else
    detected_version_total=$((detected_version_total + 1))
  fi

  echo "${update_status}${plan} ${pv} ${lv}"

  # TEMPORARY measure to prevent looping all plans during development.
  # if [ "${plan}" = "bats" ]; then
  #   echo "Breaking"
  #   break
  # fi
done

echo
echo "[ Summary ] ------------------------------------------"
echo "  Total plans:     ${plan_count_total}"
echo "  Found versions:  ${detected_version_total}"
echo
